#!/bin/bash
# SPDX-License-Identifier: MIT
# trupositive CLI - handles init command and passes through to terraform/cloudformation wrapper
# Part of trupositive: https://github.com/trupositive-ai/trupositive

set -e
set -o pipefail

# Detect infrastructure tool (terraform or cloudformation)
INFRA_TOOL=""

# Check if a file is a CloudFormation template
is_cloudformation_template() {
  local file="$1"
  [ -f "$file" ] || return 1
  
  # CloudFormation templates must have AWSTemplateFormatVersion or be SAM templates
  # More strict matching to avoid false positives
  if grep -q "^AWSTemplateFormatVersion:" "$file" 2>/dev/null || \
     grep -q "^Transform:.*AWS::Serverless" "$file" 2>/dev/null; then
    return 0
  fi
  
  # For JSON files, check for both AWSTemplateFormatVersion and Resources at root level
  if [[ "$file" == *.json ]]; then
    if grep -q '"AWSTemplateFormatVersion"' "$file" 2>/dev/null && \
       grep -q '"Resources"' "$file" 2>/dev/null; then
      return 0
    fi
  fi
  
  return 1
}

detect_infra_tool() {
  local has_yaml=false
  local has_yml=false
  local has_json=false
  local has_tf=false
  
  # Check what file types exist to avoid unnecessary globbing
  # Use find with maxdepth to safely check for files
  [ "$(find . -maxdepth 1 -name '*.yaml' -type f 2>/dev/null | head -n 1)" ] && has_yaml=true
  [ "$(find . -maxdepth 1 -name '*.yml' -type f 2>/dev/null | head -n 1)" ] && has_yml=true
  [ "$(find . -maxdepth 1 -name '*.json' -type f 2>/dev/null | head -n 1)" ] && has_json=true
  [ "$(find . -maxdepth 1 -name '*.tf' -type f 2>/dev/null | head -n 1)" ] && has_tf=true
  
  # Check for CloudFormation templates
  if [ "$has_yaml" = "true" ] || [ "$has_yml" = "true" ] || [ "$has_json" = "true" ]; then
    # Use nullglob to handle case where no files match
    shopt -s nullglob
    for file in *.yaml *.yml *.json; do
      # Ensure file exists and is a regular file
      [ -f "$file" ] || continue
      
      # Security: Ensure file is in current directory (no path traversal)
      if [[ "$file" == *"/"* ]] || [[ "$file" == *".."* ]]; then
        continue
      fi
      
      if is_cloudformation_template "$file"; then
        INFRA_TOOL="cloudformation"
        shopt -u nullglob
        return 0
      fi
    done
    shopt -u nullglob
  fi
  
  # Check for Terraform files
  if [ "$has_tf" = "true" ]; then
    INFRA_TOOL="terraform"
    return 0
  fi
  
  return 1
}

# ======================================
# CloudFormation Functions
# ======================================

# Function to generate CloudFormation parameters template
run_init_cloudformation() {
  local filename="trupositive-params.yaml"
  
  # Security: Ensure filename doesn't contain path separators
  if [[ "$filename" == *"/"* ]] || [[ "$filename" == *".."* ]]; then
    echo "âŒ Error: Invalid filename" >&2
    return 1
  fi
  
  # Check if file already exists
  if [ -f "$filename" ]; then
    echo "âš ï¸  trupositive-params.yaml already exists â€” aborting to avoid overwrite"
    echo "   Delete the file first if you want to regenerate it"
    return 1
  fi
  
  # Validate we're in a directory with CloudFormation templates
  local has_cfn_template=false
  for file in *.yaml *.yml *.json; do
    [ -f "$file" ] || continue
    if grep -q "AWSTemplateFormatVersion\|Resources:" "$file" 2>/dev/null; then
      has_cfn_template=true
      break
    fi
  done
  
  if [ "$has_cfn_template" = false ]; then
    echo "âŒ Error: No CloudFormation templates found in current directory" >&2
    echo "   Please run 'trupositive init' from a CloudFormation project directory" >&2
    return 1
  fi
  
  # Check write permissions
  if [ ! -w . ]; then
    echo "âŒ Error: No write permission in current directory" >&2
    return 1
  fi
  
  # Generate parameter template file
  cat > "$filename" <<'EOF'
# ===============================================
# trupositive generated file
# ===============================================
# This file was generated by 'trupositive init'
# It provides parameter definitions for Git metadata in CloudFormation.
# ===============================================
#
# Add these parameters to your CloudFormation template:
#
Parameters:
  GitSha:
    Type: String
    Default: "unknown"
    Description: Git commit SHA
  
  GitBranch:
    Type: String
    Default: "unknown"
    Description: Git branch name
  
  GitRepo:
    Type: String
    Default: "unknown"
    Description: Git repository URL

# ===============================================
# Usage Examples
# ===============================================
#
# Add these tags to your resources:
#
# Example 1: EC2 Instance
# Resources:
#   MyInstance:
#     Type: AWS::EC2::Instance
#     Properties:
#       # ... other properties ...
#       Tags:
#         - Key: git_sha
#           Value: !Ref GitSha
#         - Key: git_branch
#           Value: !Ref GitBranch
#         - Key: git_repo
#           Value: !Ref GitRepo
#
# Example 2: S3 Bucket
# Resources:
#   MyBucket:
#     Type: AWS::S3::Bucket
#     Properties:
#       # ... other properties ...
#       Tags:
#         - Key: git_sha
#           Value: !Ref GitSha
#         - Key: git_branch
#           Value: !Ref GitBranch
#         - Key: git_repo
#           Value: !Ref GitRepo
#
# ===============================================
# Deployment
# ===============================================
#
# The cloudformation wrapper automatically injects these parameters:
#
#   aws cloudformation deploy \
#     --template-file template.yaml \
#     --stack-name my-stack
#
# Or explicitly with parameter overrides:
#
#   aws cloudformation deploy \
#     --template-file template.yaml \
#     --stack-name my-stack \
#     --parameter-overrides GitSha=abc123 GitBranch=main GitRepo=myrepo
#
EOF
  
  echo ""
  echo "âœ¨ Created trupositive-params.yaml"
  echo "âœ”  Parameter definitions and examples provided"
  echo ""
  echo "ðŸ“ Next steps:"
  echo "   1. Copy the Parameters section to your CloudFormation template(s)"
  echo "   2. Add Git metadata tags to your resources (see examples in the file)"
  echo "   3. Use 'aws cloudformation deploy' - Git parameters are injected automatically"
  echo ""
  echo "ðŸ’¡ Tip: The cloudformation wrapper automatically passes Git metadata as parameters"
  echo ""
}

# ======================================
# Terraform Functions
# ======================================

# Function to detect existing provider blocks
# Uses more precise pattern matching to avoid false positives from comments/strings
detect_existing_provider() {
  local provider="$1"
  local provider_file=""
  local provider_line=""
  
  # Security: Validate provider input
  case "$provider" in
    aws|google|azurerm)
      # Valid provider
      ;;
    *)
      return 1
      ;;
  esac
  
  # Search for existing provider blocks
  # Pattern: provider "provider_name" { (not in comments or strings)
  for file in *.tf; do
    [ -f "$file" ] || continue
    
    # Security: Ensure file is in current directory (no path traversal)
    if [[ "$file" == *"/"* ]] || [[ "$file" == *".."* ]]; then
      continue  # Skip suspicious filenames
    fi
    if [ "$(dirname "$file")" != "." ]; then
      continue  # Skip files not in current directory
    fi
    
    # Use awk to find provider blocks, skipping comments and strings
    # Look for: provider "provider_name" { on a line (possibly with whitespace)
    result="$(awk '
      /^[[:space:]]*provider[[:space:]]+"'"$provider"'"[[:space:]]*\{/ {
        if (!/^[[:space:]]*#/) {  # Not a comment
          print FILENAME":"NR
          exit 0
        }
      }
    ' "$file" 2>/dev/null | head -1)"
    if [ -n "$result" ]; then
      provider_file=$(echo "$result" | cut -d: -f1)
      provider_line=$(echo "$result" | cut -d: -f2)
      
      # Security: Validate extracted filename
      if [[ "$provider_file" == *"/"* ]] || [[ "$provider_file" == *".."* ]]; then
        continue  # Skip suspicious filenames
      fi
      if [ "$(dirname "$provider_file")" != "." ]; then
        continue  # Skip files not in current directory
      fi
      
      echo "$provider_file:$provider_line"
      return 0
    fi
  done
  
  return 1
}

# Function to generate provider patch
generate_provider_patch() {
  local provider="$1"
  local provider_file="$2"
  local provider_line="$3"
  
  case "$provider" in
    aws)
      cat <<EOF

# Add this default_tags block to your existing provider "aws" block:
  default_tags {
    tags = {
      git_sha    = var.git_sha
      git_branch = var.git_branch
      git_repo   = var.git_repo
    }
  }
EOF
      ;;
    azurerm)
      cat <<EOF

# Azure doesn't support provider-level default_tags like AWS.
# The locals block has been automatically added to trupositive.auto.tf.
# Now add tags to each resource:
#   tags = local.default_tags
#
# Example:
# resource "azurerm_storage_account" "example" {
#   name     = "example"
#   ...
#   tags = local.default_tags
# }
EOF
      ;;
    google)
      cat <<EOF

# GCP uses labels instead of tags, and provider-wide defaults aren't uniform.
# The locals block has been automatically added to trupositive.auto.tf.
# Now add labels to each resource:
#   labels = local.default_labels
#
# Example:
# resource "google_storage_bucket" "example" {
#   name     = "example"
#   ...
#   labels = local.default_labels
# }
#
# See: https://registry.terraform.io/providers/hashicorp/google/latest/docs/guides/provider_reference#labels
EOF
      ;;
  esac
}

# Function to generate trupositive.auto.tf
run_init() {
  # Security: Hardcode filename to prevent path traversal
  local filename="trupositive.auto.tf"
  
  # Security: Ensure filename doesn't contain path separators
  if [[ "$filename" == *"/"* ]] || [[ "$filename" == *".."* ]]; then
    echo "âŒ Error: Invalid filename" >&2
    return 1
  fi
  
  # Check if file already exists
  if [ -f "$filename" ]; then
    echo "âš ï¸  trupositive.auto.tf already exists â€” aborting to avoid overwrite"
    echo "   Delete the file first if you want to regenerate it"
    return 1
  fi
  
  # Validate we're in a directory with .tf files
  if ! ls *.tf >/dev/null 2>&1; then
    echo "âŒ Error: No .tf files found in current directory" >&2
    echo "   Please run 'trupositive init' from a Terraform project directory" >&2
    return 1
  fi
  
  # Check write permissions
  if [ ! -w . ]; then
    echo "âŒ Error: No write permission in current directory" >&2
    return 1
  fi
  
  # Detect provider by checking existing .tf files
  # Use more precise pattern matching to avoid false positives from comments/strings
  local provider="azurerm"
  local provider_found=false
  
  # Security: Validate we're only processing files in current directory
  # Prevent path traversal by ensuring no subdirectories
  for file in *.tf; do
    [ -f "$file" ] || continue
    # Security: Ensure file is in current directory (no path separators)
    if [[ "$file" == *"/"* ]] || [[ "$file" == *".."* ]]; then
      continue  # Skip suspicious filenames
    fi
    # Security: Ensure it's a regular file in current directory
    if [ "$(dirname "$file")" != "." ]; then
      continue  # Skip files not in current directory
    fi
    
    # Skip lines starting with # (comments)
    # Match: whitespace* provider whitespace* "provider_name" whitespace* {
    if grep -E '^[[:space:]]*provider[[:space:]]+"aws"[[:space:]]*\{' "$file" 2>/dev/null | grep -v '^[[:space:]]*#' | grep -q .; then
      provider="aws"
      provider_found=true
      break
    elif grep -E '^[[:space:]]*provider[[:space:]]+"google"[[:space:]]*\{' "$file" 2>/dev/null | grep -v '^[[:space:]]*#' | grep -q .; then
      provider="google"
      provider_found=true
      break
    elif grep -E '^[[:space:]]*provider[[:space:]]+"azurerm"[[:space:]]*\{' "$file" 2>/dev/null | grep -v '^[[:space:]]*#' | grep -q .; then
      provider="azurerm"
      provider_found=true
      break
    fi
  done
  
  # Security: Validate provider is one of the allowed values
  case "$provider" in
    aws|google|azurerm)
      # Valid provider
      ;;
    *)
      echo "âŒ Error: Invalid provider detected: $provider" >&2
      return 1
      ;;
  esac
  
  # Check if provider block already exists
  local existing_provider=""
  if [ "$provider_found" = true ]; then
    existing_provider=$(detect_existing_provider "$provider")
  fi
  
  if [ -n "$existing_provider" ]; then
    # Provider block exists - generate variables file and patch instructions
    local provider_file=$(echo "$existing_provider" | cut -d: -f1)
    local provider_line=$(echo "$existing_provider" | cut -d: -f2)
    
    # Security: Validate provider_file to prevent path traversal
    # Only allow filenames in current directory (no path separators)
    if [[ "$provider_file" == *"/"* ]] || [[ "$provider_file" == *".."* ]]; then
      echo "âŒ Error: Invalid provider file path detected" >&2
      return 1
    fi
    
    # Validate provider_file exists and is a regular file in current directory
    if [ ! -f "$provider_file" ] || [ "$(dirname "$provider_file")" != "." ]; then
      echo "âŒ Error: Provider file validation failed" >&2
      return 1
    fi
    
    # Generate locals block for Azure/GCP (AWS doesn't need it)
    local locals_block=""
    if [ "$provider" = "azurerm" ]; then
      locals_block="

# Default tags that will be applied to all resources
locals {
  default_tags = {
    git_sha    = var.git_sha
    git_branch = var.git_branch
    git_repo   = var.git_repo
  }
}"
    elif [ "$provider" = "google" ]; then
      locals_block="

# Default labels that can be applied to resources
locals {
  default_labels = {
    git_sha    = var.git_sha
    git_branch = var.git_branch
    git_repo   = var.git_repo
  }
}"
    fi
    
    # Write variables file (and locals for Azure/GCP)
    cat > "$filename" <<EOF
# ===============================================
# trupositive generated file
# ===============================================
# This file was generated by 'trupositive init'
# It auto-configures Git tagging in Terraform.
# Safe to delete! Do not modify the generated file.
# ===============================================

variable "git_sha" {
  type    = string
  default = "unknown"
}

variable "git_branch" {
  type    = string
  default = "unknown"
}

variable "git_repo" {
  type    = string
  default = "unknown"
}
$locals_block
EOF
    
    echo ""
    if [ "$provider" = "aws" ]; then
      echo "âœ¨ Created trupositive.auto.tf (variables only)"
    else
      echo "âœ¨ Created trupositive.auto.tf (variables and locals block)"
    fi
    echo ""
    echo "âš ï¸  Provider block already exists in: $provider_file (line $provider_line)"
    echo ""
    if [ "$provider" = "aws" ]; then
      echo "To enable automatic tagging, add the following to your existing"
      echo "provider \"$provider\" block in $provider_file:"
    else
      echo "To enable automatic tagging, add the following configuration"
      echo "to your Terraform files:"
    fi
    echo ""
    generate_provider_patch "$provider" "$provider_file" "$provider_line"
    echo ""
    if [ "$provider" = "aws" ]; then
      echo "After adding default_tags, commit both files:"
    else
      echo "After adding the configuration, commit both files:"
    fi
    # Security: Sanitize provider_file for display (already validated above)
    local safe_provider_file="$provider_file"
    echo "  git add trupositive.auto.tf $safe_provider_file"
    echo "  git commit -m \"Enable trupositive Terraform tagging\""
    echo ""
    
  else
    # No provider block exists - generate complete file
    local provider_block=""
    case "$provider" in
      aws)
        provider_block="provider \"aws\" {
  default_tags {
    tags = {
      git_sha    = var.git_sha
      git_branch = var.git_branch
      git_repo   = var.git_repo
    }
  }
}"
        ;;
      google)
        provider_block="provider \"google\" {
  # GCP configuration
}

# Default labels that can be applied to resources
# Note: GCP uses labels instead of tags, and provider-wide defaults aren't uniform.
# You may need to add labels per resource or use a module.
locals {
  default_labels = {
    git_sha    = var.git_sha
    git_branch = var.git_branch
    git_repo   = var.git_repo
  }
}

# Example usage:
# resource \"google_storage_bucket\" \"example\" {
#   name     = \"example\"
#   ...
#   labels = local.default_labels
# }
#
# See: https://registry.terraform.io/providers/hashicorp/google/latest/docs/guides/provider_reference#labels
"
        ;;
      azurerm)
        provider_block="provider \"azurerm\" {
  features {}
}

# Default tags that will be applied to all resources
locals {
  default_tags = {
    git_sha    = var.git_sha
    git_branch = var.git_branch
    git_repo   = var.git_repo
  }
}"
        ;;
    esac
    
    # Write the complete file
    cat > "$filename" <<EOF
# ===============================================
# trupositive generated file
# ===============================================
# This file was generated by 'trupositive init'
# It auto-configures Git tagging in Terraform.
# Safe to delete! Do not modify the generated file.
# ===============================================

variable "git_sha" {
  type    = string
  default = "unknown"
}

variable "git_branch" {
  type    = string
  default = "unknown"
}

variable "git_repo" {
  type    = string
  default = "unknown"
}

$provider_block
EOF
    
    echo ""
    echo "âœ¨ Created trupositive.auto.tf"
    echo "âœ”  Git tagging configured automatically (detected provider: $provider)"
    echo "ðŸ” Safe to delete the file if you change your tagging strategy"
    echo "ðŸ“ Commit the file if you want permanent tagging"
    echo ""
  fi
}

# Handle init command
if [ "$1" = "init" ]; then
  # Detect infrastructure tool
  if ! detect_infra_tool; then
    echo "âŒ Error: No Terraform or CloudFormation files found" >&2
    echo "   Please run 'trupositive init' from a Terraform or CloudFormation project directory" >&2
    exit 1
  fi
  
  case "$INFRA_TOOL" in
    terraform)
      echo "ðŸ” Detected Terraform project"
      run_init
      ;;
    cloudformation)
      echo "ðŸ” Detected CloudFormation project"
      run_init_cloudformation
      ;;
    *)
      echo "âŒ Error: Unknown infrastructure tool" >&2
      exit 1
      ;;
  esac
  exit $?
fi

# For all other commands, detect tool and pass through to appropriate wrapper
if ! detect_infra_tool; then
    # If we can't detect, default to terraform for backward compatibility
    INFRA_TOOL="terraform"
fi

case "$INFRA_TOOL" in
  terraform)
    # Find terraform-real to avoid infinite loop
    # Priority: terraform-real (from installation) > which terraform > terraform in PATH
    TERRAFORM_WRAPPER=""
    if [ -f ~/.local/bin/terraform-real ]; then
        TERRAFORM_WRAPPER=~/.local/bin/terraform-real
    elif command -v terraform-real >/dev/null 2>&1; then
        TERRAFORM_WRAPPER=$(command -v terraform-real)
    elif [ -f ~/.local/bin/terraform ]; then
        # Use the wrapper if it exists
        TERRAFORM_WRAPPER=~/.local/bin/terraform
    elif command -v terraform >/dev/null 2>&1; then
        TERRAFORM_WRAPPER=$(command -v terraform)
    else
        echo "Error: terraform binary not found. Please install Terraform." >&2
        exit 1
    fi
    exec "$TERRAFORM_WRAPPER" "$@"
    ;;
    
  cloudformation)
    # Find cloudformation wrapper
    CLOUDFORMATION_WRAPPER=""
    if [ -f ~/.local/bin/cloudformation ]; then
        CLOUDFORMATION_WRAPPER=~/.local/bin/cloudformation
    elif command -v cloudformation >/dev/null 2>&1; then
        CLOUDFORMATION_WRAPPER=$(command -v cloudformation)
    else
        echo "Error: cloudformation wrapper not found. Please install trupositive properly." >&2
        exit 1
    fi
    exec "$CLOUDFORMATION_WRAPPER" "$@"
    ;;
    
  *)
    echo "Error: Unknown infrastructure tool" >&2
    exit 1
    ;;
esac
